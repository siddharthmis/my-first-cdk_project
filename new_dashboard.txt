import boto3
import json
import logging

# Initialize AWS clients
dynamodb = boto3.client('dynamodb')
cloudwatch = boto3.client('cloudwatch')

# Setup logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Function to get all DynamoDB entries
def get_all_dynamodb_entries():
    try:
        response = dynamodb.scan(TableName='ResourceMetrics')
        entries = response['Items']
        logger.info(f"Fetched {len(entries)} entries from DynamoDB.")
        return entries
    except Exception as e:
        logger.error(f"Error fetching entries from DynamoDB: {e}")
        return []

# Function to generate a dynamic log group name based on resource type and name
def generate_log_group_name(resource_type, resource_name):
    # Example: /aws/service/resource_name (adjust according to your naming convention)
    return f"/aws/{resource_type.lower()}/{resource_name}"

# Function to create/update a CloudWatch Dashboard with dynamically generated metrics and log group names
def create_dashboard(resource_counts, metrics_data, logs_data):
    dashboard_name = "DynamicResourceDashboard"
    widgets = []

    # Add resource counters with dynamically generated metrics for each service
    x = 0  # Widget x-position in the dashboard
    y = 0  # Widget y-position in the dashboard
    for service, count in resource_counts.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 6,
            "height": 6,
            "properties": {
                "metrics": metrics_data[service],  # Dynamic metrics for the service
                "view": "timeSeries",
                "region": "us-east-1",  # Adjust to your region
                "title": f"{service} Resource Metrics",
                "stat": "Average",
                "period": 300,
                "liveData": True,  # Enable live data streaming
                "annotations": {
                    "horizontal": [
                        {
                            "label": "High Threshold",
                            "value": 80,
                            "color": "#ff0000",
                            "fill": "above"
                        }
                    ]
                }
            }
        }
        widgets.append(widget)
        y += 6  # Move to the next widget position in the dashboard

    # Add CloudWatch Logs Insights widgets for each service/resource
    for service, log_group_name in logs_data.items():
        log_widget = {
            "type": "log",
            "x": 0,
            "y": y,
            "width": 12,
            "height": 6,
            "properties": {
                "logGroupNames": [log_group_name],
                "queryString": "fields @timestamp, @message | sort @timestamp desc | limit 20",
                "view": "table",
                "region": "us-east-1",
                "title": f"{service} Logs Query"
            }
        }
        widgets.append(log_widget)
        y += 6  # Move to the next position for additional widgets

    # Create the dashboard body with widgets
    dashboard_body = {
        "widgets": widgets
    }

    # Put the dashboard
    try:
        cloudwatch.put_dashboard(
            DashboardName=dashboard_name,
            DashboardBody=json.dumps(dashboard_body)
        )
        logger.info(f"Successfully created/updated CloudWatch dashboard: {dashboard_name}")
    except Exception as e:
        logger.error(f"Error creating/updating CloudWatch dashboard: {e}")

# Main Lambda handler function
def lambda_handler(event, context):
    # Fetch all existing entries in DynamoDB
    dynamodb_entries = get_all_dynamodb_entries()

    # Create a dictionary to count resources by service and hold dynamic metrics and log group data
    resource_counts = {}
    metrics_data = {}
    logs_data = {}

    for entry in dynamodb_entries:
        resource_id = entry['ResourceID']['S']
        resource_type = entry['ResourceType']['S']
        resource_name = entry.get('ResourceName', {}).get('S', resource_id)  # Use ResourceName if available, otherwise ResourceID
        metric_name = entry['MetricName']['S']
        namespace = entry['Namespace']['S']

        # Count resources by service type
        resource_counts[resource_type] = resource_counts.get(resource_type, 0) + 1

        # Add dynamic metrics for the service
        if resource_type not in metrics_data:
            metrics_data[resource_type] = []
        metrics_data[resource_type].append([namespace, metric_name, "ResourceID", resource_id])

        # Dynamically generate log group names based on resource type and name
        log_group_name = generate_log_group_name(resource_type, resource_name)
        logs_data[resource_type] = log_group_name

    # Create/Update CloudWatch Dashboard with dynamic metrics and logs
    create_dashboard(resource_counts, metrics_data, logs_data)

    return {
        'statusCode': 200,
        'body': json.dumps('CloudWatch Dashboard creation and update completed successfully')
    }



#################################################################################################



import boto3
import json
import logging

# Initialize AWS clients
dynamodb = boto3.client('dynamodb')
cloudwatch = boto3.client('cloudwatch')

# Setup logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Function to get all DynamoDB entries with proper error handling
def get_all_dynamodb_entries():
    try:
        response = dynamodb.scan(TableName='ResourceMetrics')
        entries = response['Items']
        logger.info(f"Fetched {len(entries)} entries from DynamoDB.")
        return entries
    except Exception as e:
        logger.error(f"Error fetching entries from DynamoDB: {e}")
        return []

# Function to generate a dynamic log group name based on resource type and name
def generate_log_group_name(resource_type, resource_name):
    try:
        log_group_name = f"/aws/{resource_type.lower()}/{resource_name}"
        logger.info(f"Generated log group name: {log_group_name} for resource: {resource_name}")
        return log_group_name
    except Exception as e:
        logger.error(f"Error generating log group name for {resource_type}, {resource_name}: {e}")
        return None

# Widget for Resource Summary
def create_resource_summary_widgets(resource_counts):
    widgets = []
    x, y = 0, 0
    for resource_type, count in resource_counts.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 12,
            "height": 6,
            "properties": {
                "metrics": [["CustomNamespace", "ResourceCount", "Service", resource_type]],
                "view": "singleValue",
                "region": "us-east-1",
                "title": f"{resource_type} Resource Count: {count}",
                "stat": "Sum"
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Aggregate Metrics
def create_aggregate_metric_widget(metrics_data):
    widgets = []
    x, y = 0, 0
    for resource_type, metric_info in metrics_data.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 24,
            "height": 6,
            "properties": {
                "metrics": metric_info['metrics'],
                "view": "timeSeries",
                "stat": "Average",
                "region": "us-east-1",
                "title": f"Average {metric_info['metrics'][0][1]} for {resource_type}",
                "period": 300,
                "liveData": True
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Top N Resources
def create_top_n_widget(resource_type, metric_name, n=5):
    widget = {
        "type": "log",
        "x": 0,
        "y": 0,
        "width": 24,
        "height": 6,
        "properties": {
            "queryString": f"fields @timestamp, @message | filter MetricName = '{metric_name}' "
                           f"| sort by @message desc | limit {n}",
            "logGroupNames": [f"/aws/{resource_type.lower()}/*"],
            "view": "table",
            "region": "us-east-1",
            "title": f"Top {n} {resource_type} Resources by {metric_name}"
        }
    }
    return widget

# Widget for Status Summary
def create_status_summary_widget(resource_counts, unhealthy_counts):
    widgets = []
    x, y = 0, 0
    for resource_type, count in resource_counts.items():
        unhealthy = unhealthy_counts.get(resource_type, 0)
        healthy = count - unhealthy
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 12,
            "height": 6,
            "properties": {
                "metrics": [["CustomNamespace", "HealthyCount", "Service", resource_type],
                            ["CustomNamespace", "UnhealthyCount", "Service", resource_type]],
                "view": "singleValue",
                "region": "us-east-1",
                "title": f"{resource_type} - Healthy: {healthy}, Unhealthy: {unhealthy}",
                "stat": "Sum"
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Anomaly Detection
def create_anomaly_detection_widget(metrics_data):
    widgets = []
    x, y = 0, 0
    for resource_type, metric_info in metrics_data.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 24,
            "height": 6,
            "properties": {
                "metrics": metric_info['metrics'],
                "view": "timeSeries",
                "stat": "Average",
                "region": "us-east-1",
                "title": f"Anomaly Detection for {resource_type}",
                "period": 300,
                "liveData": True,
                "annotations": {
                    "horizontal": [
                        {
                            "label": "Anomaly Detection",
                            "fill": "below",
                            "color": "#ff0000",
                            "anomalyDetection": True  # Enable anomaly detection
                        }
                    ]
                }
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Main Lambda handler function
def lambda_handler(event, context):
    try:
        # Fetch all existing entries in DynamoDB
        dynamodb_entries = get_all_dynamodb_entries()

        # Initialize data structures
        resource_counts = {}
        metrics_data = {}
        logs_data = {}
        unhealthy_counts = {}  # Simulating unhealthy resource counts, you can populate it based on real data

        # Process each entry in DynamoDB
        for entry in dynamodb_entries:
            try:
                resource_id = entry['ResourceID']['S']
                resource_type = entry['ResourceType']['S']
                resource_name = entry.get('ResourceName', {}).get('S', resource_id)
                metric_name = entry['MetricName']['S']
                namespace = entry['Namespace']['S']
                statistic = entry.get('Statistic', {}).get('S', "Average")
                threshold = float(entry.get('Threshold', {}).get('N', "80"))

                # Update resource counts
                resource_counts[resource_type] = resource_counts.get(resource_type, 0) + 1

                # Collect metrics for aggregate widget
                if resource_type not in metrics_data:
                    metrics_data[resource_type] = {'metrics': [], 'stat': statistic, 'threshold': threshold}
                metrics_data[resource_type]['metrics'].append([namespace, metric_name, "ResourceID", resource_id])

                # Generate log group name dynamically
                log_group_name = generate_log_group_name(resource_type, resource_name)
                if log_group_name:
                    logs_data[resource_type] = log_group_name

            except Exception as e:
                logger.error(f"Error processing DynamoDB entry: {e}")

        # Create widgets
        widgets = []
        widgets.extend(create_resource_summary_widgets(resource_counts))  # Resource Summary
        widgets.extend(create_aggregate_metric_widget(metrics_data))      # Aggregate Metrics
        widgets.append(create_top_n_widget("EC2", "CPUUtilization", 5))   # Top N Resources (example for EC2)
        widgets.extend(create_status_summary_widget(resource_counts, unhealthy_counts))  # Status Summary
        widgets.extend(create_anomaly_detection_widget(metrics_data))     # Anomaly Detection

        # Create the dashboard body with widgets
        dashboard_body = {"widgets": widgets}

        # Create or update the CloudWatch dashboard
        cloudwatch.put_dashboard(
            DashboardName="DynamicResourceDashboard",
            DashboardBody=json.dumps(dashboard_body)
        )
        logger.info("Successfully created/updated CloudWatch dashboard.")

    except Exception as e:
        logger.error(f"Lambda execution failed: {e}")

    return {
        'statusCode': 200,
        'body': json.dumps('CloudWatch Dashboard creation and update completed successfully')
    }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


import boto3
import json
import logging

# Initialize AWS clients
dynamodb = boto3.client('dynamodb')
cloudwatch = boto3.client('cloudwatch')
logs_client = boto3.client('logs')

# Setup logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Function to get all DynamoDB entries with proper error handling
def get_all_dynamodb_entries():
    try:
        response = dynamodb.scan(TableName='ResourceMetrics')
        entries = response['Items']
        logger.info(f"Fetched {len(entries)} entries from DynamoDB.")
        return entries
    except Exception as e:
        logger.error(f"Error fetching entries from DynamoDB: {e}")
        return []

# Function to look up log group with pagination and filtering within the /aws/ prefix
def lookup_log_group(resource_name):
    try:
        log_group_prefix = "/aws/"
        found_log_group = None
        next_token = None

        # Paginate through log groups to find a match
        while True:
            if next_token:
                response = logs_client.describe_log_groups(logGroupNamePrefix=log_group_prefix, nextToken=next_token)
            else:
                response = logs_client.describe_log_groups(logGroupNamePrefix=log_group_prefix)
            
            log_groups = response.get('logGroups', [])
            next_token = response.get('nextToken', None)

            # Search for any log group that contains the resource name
            for log_group in log_groups:
                log_group_name = log_group['logGroupName']
                if resource_name in log_group_name:
                    logger.info(f"Found log group: {log_group_name} for resource: {resource_name}")
                    found_log_group = log_group_name
                    break  # Stop searching once we find a match
            
            if found_log_group or not next_token:
                break  # Exit the loop if we found a match or no more log groups to search

        # Return the found log group, or fallback to the default log group
        if found_log_group:
            return found_log_group
        else:
            logger.warning(f"No log group found for resource: {resource_name}. Using default log group.")
            return "/aws/default-log-group"

    except Exception as e:
        logger.error(f"Error looking up log group for {resource_name}: {e}")
        return "/aws/default-log-group"

# Widget for Resource Summary
def create_resource_summary_widgets(resource_counts):
    widgets = []
    x, y = 0, 0
    for resource_type, count in resource_counts.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 12,
            "height": 6,
            "properties": {
                "metrics": [["AWS/Service", "ResourceCount", "Service", resource_type]],
                "view": "singleValue",
                "region": "us-east-1",
                "title": f"{resource_type} Resource Count: {count}",
                "stat": "Sum"
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Aggregate Metrics
def create_aggregate_metric_widget(metrics_data):
    widgets = []
    x, y = 0, 0
    for resource_type, metric_info in metrics_data.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 24,
            "height": 6,
            "properties": {
                "metrics": metric_info['metrics'],
                "view": "timeSeries",
                "stat": "Average",
                "region": "us-east-1",
                "title": f"Average {metric_info['metrics'][0][1]} for {resource_type}",
                "period": 300,
                "liveData": True
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Top N Resources
def create_top_n_widget(resource_type, metric_name, n=5):
    widget = {
        "type": "log",
        "x": 0,
        "y": 0,
        "width": 24,
        "height": 6,
        "properties": {
            "queryString": f"fields @timestamp, @message | filter MetricName = '{metric_name}' "
                           f"| sort by @message desc | limit {n}",
            "logGroupNames": [f"/aws/{resource_type.lower()}/*"],
            "view": "table",
            "region": "us-east-1",
            "title": f"Top {n} {resource_type} Resources by {metric_name}"
        }
    }
    return widget

# Widget for Status Summary
def create_status_summary_widget(resource_counts, unhealthy_counts):
    widgets = []
    x, y = 0, 0
    for resource_type, count in resource_counts.items():
        unhealthy = unhealthy_counts.get(resource_type, 0)
        healthy = count - unhealthy
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 12,
            "height": 6,
            "properties": {
                "metrics": [["AWS/Service", "HealthyCount", "Service", resource_type],
                            ["AWS/Service", "UnhealthyCount", "Service", resource_type]],
                "view": "singleValue",
                "region": "us-east-1",
                "title": f"{resource_type} - Healthy: {healthy}, Unhealthy: {unhealthy}",
                "stat": "Sum"
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Widget for Anomaly Detection
def create_anomaly_detection_widget(metrics_data):
    widgets = []
    x, y = 0, 0
    for resource_type, metric_info in metrics_data.items():
        widget = {
            "type": "metric",
            "x": x,
            "y": y,
            "width": 24,
            "height": 6,
            "properties": {
                "metrics": metric_info['metrics'],
                "view": "timeSeries",
                "stat": "Average",
                "region": "us-east-1",
                "title": f"Anomaly Detection for {resource_type}",
                "period": 300,
                "liveData": True,
                "annotations": {
                    "horizontal": [
                        {
                            "label": "Anomaly Detection",
                            "fill": "below",
                            "color": "#ff0000",
                            "anomalyDetection": True  # Enable anomaly detection
                        }
                    ]
                }
            }
        }
        widgets.append(widget)
        y += 6
    return widgets

# Main Lambda handler function
def lambda_handler(event, context):
    try:
        # Fetch all existing entries in DynamoDB
        dynamodb_entries = get_all_dynamodb_entries()

        # Initialize data structures
        resource_counts = {}
        metrics_data = {}
        logs_data = {}
        unhealthy_counts = {}

        # Process each entry in DynamoDB
        for entry in dynamodb_entries:
            try:
                resource_id = entry['ResourceID']['S']
                resource_type = entry['ResourceType']['S']
                resource_name = entry.get('ResourceName', {}).get('S', resource_id)
                metric_name = entry['MetricName']['S']
                namespace = entry['Namespace']['S']
                statistic = entry.get('Statistic', {}).get('S', "Average")
                threshold = float(entry.get('Threshold', {}).get('N', "80"))

                # Update resource counts
                resource_counts[resource_type] = resource_counts.get(resource_type, 0) + 1

                # Collect metrics for aggregate widget
                if resource_type not in metrics_data:
                    metrics_data[resource_type] = {'metrics': [], 'stat': statistic, 'threshold': threshold}
                metrics_data[resource_type]['metrics'].append([namespace, metric_name, "ResourceID", resource_id])

                # Look up log group based on resource name
                log_group_name = lookup_log_group(resource_name)
                if log_group_name:
                    logs_data[resource_type] = log_group_name

            except Exception as e:
                logger.error(f"Error processing DynamoDB entry: {e}")

        # Create widgets
        widgets = []
        widgets.extend(create_resource_summary_widgets(resource_counts))  # Resource Summary
        widgets.extend(create_aggregate_metric_widget(metrics_data))      # Aggregate Metrics
        widgets.append(create_top_n_widget("EC2", "CPUUtilization", 5))   # Top N Resources (example for EC2)
        widgets.extend(create_status_summary_widget(resource_counts, unhealthy_counts))  # Status Summary
        widgets.extend(create_anomaly_detection_widget(metrics_data))     # Anomaly Detection

        # Create the dashboard body with widgets
        dashboard_body = {"widgets": widgets}

        # Create or update the CloudWatch dashboard
        cloudwatch.put_dashboard(
            DashboardName="DynamicResourceDashboard",
            DashboardBody=json.dumps(dashboard_body)
        )
        logger.info("Successfully created/updated CloudWatch dashboard.")

    except Exception as e:
        logger.error(f"Lambda execution failed: {e}")

    return {
        'statusCode': 200,
        'body': json.dumps('CloudWatch Dashboard creation and update completed successfully')
    }
